#!/usr/bin/env python3
import concurrent.futures
import os, sys, argparse, logging, yaml, asyncio
from pprint import pprint

DN = os.path.dirname(os.path.abspath(__file__))

sys.path.append(DN + '/src');
from cloudinventario.cloudinventario import CloudInventario

# getArgs
def getArgs():
   parser = argparse.ArgumentParser(description='CloudInventory args')
   parser.add_argument('-c', '--config', action='store', required=True,
                       help='Config file')
   parser.add_argument('-l', '--list', action='store_true',
                       help='List collectors')
   parser.add_argument('-n', '--name', action='store',
                       help='Collector to run')
   parser.add_argument('-a', '--all', action='store_true',
                       help='Run all collectors')
   parser.add_argument('-p', '--prune', action='store_true',
                       help='Cleanup old data')
   parser.add_argument('-f', '--forks', action='store', nargs='?', const=7, type=int,
                       help='Parallel fork')
   parser.add_argument('-v', '--verbose', action='count', default=0,
                       help='Verbose')
   args = parser.parse_args()
   return args

# loadConfig
def loadConfig(config_file):
   with open(config_file) as file:
       return yaml.safe_load(file)
   return None

# collect
def collect(cinv, name):
   logging.info("collector name={}".format(name))
   inventory = cinv.collect(name)
   if inventory is not None:
#      pprint(inventory)
      logging.info("storing data for name={}".format(name))
      cinv.store(inventory)
      return True
   else:
      logging.info("collector failed name={}".format(name))
   return False

# main
async def main(args, executor):

  # init logging
  level = logging.WARNING
  if args.verbose > 1:
    level = logging.DEBUG
  elif args.verbose > 0:
    level = logging.INFO
  logging.basicConfig(format='%(asctime)s [%(levelname)s] %(message)s', level=level)

  # parse config
  config = loadConfig(args.config)
  cinv = CloudInventario(config)

  if args.prune:
    cinv.cleanup(days = 5)

  if args.list:
    for col in cinv.collectors:
      print("{}".format(col))
    return 0
  elif args.name:
    inventory = cinv.collect(args.name)
    cinv.store(inventory)
    return 0
  elif args.all:
    cinv.store([])

    loop = asyncio.get_event_loop()
    futures = [
      loop.run_in_executor(executor, collect, cinv, col)
        for col in cinv.collectors
    ]
    completed, pending = await asyncio.wait(futures)
    return 0
  elif args.prune:
    return 0
  else:
    print("No action specified !", file=sys.stderr)
    return 1

# MAIN (with parallel execution)
args = getArgs()
args.forks = 1 # TODO: forks not working now
executor = concurrent.futures.ThreadPoolExecutor(max_workers = args.forks)
event_loop = asyncio.get_event_loop()
try:
  ret = event_loop.run_until_complete(main(args, executor))
finally:
  event_loop.close()
sys.exit(ret)
